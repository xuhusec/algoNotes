## Number of Islands

[Link](https://leetcode.com/problems/number-of-islands/)

Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return *the number of islands*.

An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

### Solution

This question would group adjacent '1's horizontally and vertically as one group or join and merge an existing groups of those 1's into one group. We can use Union Find here. Similar to the "Number of Provinces", every time two groups joins we would decrease the number of groups by 1. The difference here is that we would only count 1's as individual group in the beginning. Of course, one can join all 1's first and count those x == find(x) in another iteration to get the answer.  But if you want to count one iteration, we can just return 0 and 1 from the union function to tell if two groups are join. And minus the it from number of groups along the road. Although at a given point, this might be negative but after the whole process, this would be the correct answer.

```java
    private final int[][] DIRS = {{1,0},{-1,0},{0,1},{0,-1}};
    public int numIslands(char[][] grid) {
        
        final int N = grid.length;
        final int M = grid[0].length;
        
        UnionFind uf = new UnionFind (N * M);
        int res = 0;
        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < M; ++j) {
                if (grid[i][j] == '1') {
                    res++;
                    int idx = mapToId(i, j , M);
                    for (int[] dir : DIRS) {
                        int r = i + dir[0];
                        int c = j + dir[1];
                        if (r >= 0 && r < N && c >=0 && c < M && grid[r][c] == '1') {
                            res -= uf.union(idx, mapToId(r,c,M));
                        }
                    }
                }
            }
        }
        return res;
    }
    
    private int mapToId(int r, int c, int M) {
        return r * M + c; 
    }
    
    private static class UnionFind {
        private int[] parent;
        private int[] rank;
        
        public UnionFind(int n) {
            this.parent = new int[n];
            this.rank = new int[n];
            for (int i = 0; i < n; ++i) {
                parent[i] = i;
                rank[i] = 1;
            }
        }
        
        public int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }
        
        public int union(int x, int y) {
            int pX = find(x);
            int pY = find(y);
            if (pX == pY) {
                return 0;
            }
            if (rank[pX] > rank[pY]) {
                rank[pX] += rank[pY];
                parent[pY] = pX;
            } else {
                rank[pY] += rank[pX];
                parent[pX] = pY;
            }
            return 1;
        }
    }
```

Time complexity: 4mn\*2\*time of find(x) O(mn\*time of find(x)) . where m and n are # of rows and # columns respectively  The time of find(x) with path compression is the reverse function of Ackermann function with respect to total number of element. That is usually considered almost constant 

Space complexity parent array and rank array O(m*n)

Another solution is DFS. This has been describe in the [DFS section](..\DFS_BFS\04.Number_of_Islands__Minesweeper.md).

