## Maximal Square

[link](https://leetcode.com/problems/maximal-square/)

In a matrix, there are only 0's and 1's. Find out the maximal area of square of 1's.

A simple solution is to iterate every cell and check the square by iterating  all possible side if all the cells are 1's. Apparently, many duplication work is there. When calculate cell [i,j]. It is search again on cell[i-1,j-1], the new horizontal and vertical sides.   

DP

To calculate maximal square with (i,j) as the bottom right corner. We can check the length of side of maximal square with (i-1,j-1), the consecutive one's in  in row i ended in col j and the the consecutive one's in col j ended in row i. So we need three auxiliary matrix. Two matrices are the prefix sum of each row and col. And the matrix of the maximal square.

```java
squares[i][j] = Min(squares[i-1][j-1],rows[i][j-1],cols[i-1][j])) + 1;
```

```java
    public int maximalSquare(char[][] matrix) {
        final int N = matrix.length;
        final int M = matrix[0].length;
        int[][] rows = new int[N+1][M+1];
        int[][] cols = new int[N+1][M+1];
        int[][] squares = new int[N+1][M+1];
        int sqrt = 0;
        for (int i = 1; i <= N; ++i) {
            for (int j = 1; j <= M; ++j) {
                if (matrix[i-1][j-1] == '0') { continue; }
                rows[i][j] = rows[i][j-1] + 1;
                cols[i][j] = cols[i-1][j] + 1;
                squares[i][j] = Math.min(squares[i-1][j-1], Math.min(rows[i][j-1],cols[i-1][j])) + 1;
                sqrt = Math.max(sqrt,squares[i][j]);
            }
        }
        return sqrt*sqrt;
    }
```

Time complexity: O(MN)

Space complexity: O(MN) three matrix are all N+1 * M+1

However, this can be optimized with only auxiliary matrix. Note squares[i]\[j-1] is the small one of squares[i-1]\[j-1] and row[i]\[j-1].  If squares[i-1]\[j-1] >  row[i]\[j-1], squares[i]\[j-1]  = row[i]\[j-1] because cell (i, j -1 - row[i]\[j-1]) must be 0. So the maximal square with (i,j-1) would be with side as long as row[i]\[j-1]. If  squares[i-1]\[j-1] <  row[i]\[j-1], there must be at least one zero around the upper side and the left side. Similarly, square[i-1]\[j] is the small one of square[i-1]\[j-1] and col[i-1]\[j]. Because wo only care the minimal of squares[i-1]\[j-1],rows[i]\[j-1] and cols[i-1]\[j]. It is equivalent to minimal of  squares[i-1]\[j-1],  squares[i]\[j-1] and  squares[i-1]\[j].

```
dp[i][j] = Min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1]) + 1 for matrix[i][j] = 1
```

```java
public int maximalSquare(char[][] matrix) {
        final int N = matrix.length;
        final int M = matrix[0].length;
        int[][] dp = new int[N+1][M+1];
        int sqrt = 0;
        for (int i = 1; i <= N; ++i) {
            for (int j = 1; j <= M; ++j) {
                if (matrix[i-1][j-1] == '0') { continue; }
                dp[i][j] = dp[i-1][j-1] < 1 ? 1 : Math.min(dp[i-1][j-1], Math.min(dp[i-1][j],dp[i][j-1])) + 1;
                sqrt = Math.max(sqrt,squares[i][j]);
            }
        }
        return sqrt*sqrt;
    }
```

Time complexity: iterate over matrix O(NM)

Space complexity: O(MN)

After reducing to only one auxiliary matrix, the space can be future reduced.

```java
    public int maximalSquare(char[][] matrix) {
        final int N = matrix.length;
        final int M = matrix[0].length;
        int[] dp = new int[M + 1];
        int sqrt = 0;
        for (int i = 1; i <= N; ++i) {
            int[] temp = new int[M + 1];
            for (int j = 1; j <= M; ++j) {
                if (matrix[i - 1][j - 1] == '0') { continue; }
                temp[j] = Math.min(dp[j - 1], Math.min(dp[j],temp[j - 1])) + 1;
                sqrt = Math.max(sqrt,temp[j]);
            }
            dp = temp;
        }
        return sqrt*sqrt;
    }
```

Time complexity: O(NM)

Space complexity: O(M)

